# -*- coding: UTF-8 –*-
# from PyQt5 import uic
# from PyQt5 import QtCore,QtGui,QtWidgets
# from PyQt5.QtWidgets import QApplication,QMainWindow
import os
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
import sys
import cv2
import time
from PIL import Image
import numpy as np
import tensorflow as tf
import re
import requests
from shutil import copy2
import random
import shutil

# 以上是引入使用的第三方库函数
# ----------------------------分割线----------------------------
# 以下代码为GUI界面代码

# # 这里的GUI界面使用Pyqt5制作，界面.ui文件使用Qt designer制作，使用pyuic5转为.py文件
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'try1.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_classification(object):
    def setupUi(self, classification):
        classification.setObjectName("classification")
        classification.resize(972, 680)
        self.horizontalLayout = QtWidgets.QHBoxLayout(classification)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.tabWidget = QtWidgets.QTabWidget(classification)
        font = QtGui.QFont()
        font.setPointSize(9)
        self.tabWidget.setFont(font)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.groupBox = QtWidgets.QGroupBox(self.tab)
        self.groupBox.setTitle("")
        self.groupBox.setObjectName("groupBox")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_16 = QtWidgets.QLabel(self.groupBox)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_16.setFont(font)
        self.label_16.setObjectName("label_16")
        self.verticalLayout.addWidget(self.label_16)
        self.pushButton = QtWidgets.QPushButton(self.groupBox)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton.setFont(font)
        self.pushButton.setObjectName("pushButton")
        self.verticalLayout.addWidget(self.pushButton)
        self.comboBox = QtWidgets.QComboBox(self.groupBox)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.comboBox.setFont(font)
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("")
        self.verticalLayout.addWidget(self.comboBox)
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem)
        self.label_7 = QtWidgets.QLabel(self.groupBox)
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(True)
        font.setWeight(75)
        self.label_7.setFont(font)
        self.label_7.setObjectName("label_7")
        self.verticalLayout.addWidget(self.label_7)
        self.label_modelname = QtWidgets.QLabel(self.groupBox)
        font = QtGui.QFont()
        font.setPointSize(13)
        self.label_modelname.setFont(font)
        self.label_modelname.setObjectName("label_modelname")
        self.verticalLayout.addWidget(self.label_modelname)
        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem1)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.horizontalLayout_2.addWidget(self.groupBox)
        self.groupBox_3 = QtWidgets.QGroupBox(self.tab)
        self.groupBox_3.setTitle("")
        self.groupBox_3.setObjectName("groupBox_3")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.groupBox_3)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_9 = QtWidgets.QLabel(self.groupBox_3)
        self.label_9.setText("")
        # 适配窗口大小,更改图片的尺寸，适配界面的大小
        file_path=os.getcwd()
        img=file_path+"/初始化图片.jpg" # todo 这里需要自己设定目录
        self.target=QtGui.QPixmap(img)
        self.label_9.setPixmap(self.target) #todo 修改
        self.label_9.setObjectName("label_9")
        self.verticalLayout_3.addWidget(self.label_9)
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.label_2 = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 1, 1, 1, 1)
        self.label_4 = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_4.setFont(font)
        self.label_4.setObjectName("label_4")
        self.gridLayout.addWidget(self.label_4, 1, 0, 1, 1)
        self.label_costtime = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_costtime.setFont(font)
        self.label_costtime.setObjectName("label_costtime")
        self.gridLayout.addWidget(self.label_costtime, 1, 2, 1, 1)
        self.label_accuracy = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_accuracy.setFont(font)
        self.label_accuracy.setObjectName("label_accuracy")
        self.gridLayout.addWidget(self.label_accuracy, 2, 2, 1, 1)
        self.label_objname = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_objname.setFont(font)
        self.label_objname.setObjectName("label_objname")
        self.gridLayout.addWidget(self.label_objname, 2, 1, 1, 1)
        self.pushButton_clean = QtWidgets.QPushButton(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton_clean.setFont(font)
        self.pushButton_clean.setObjectName("pushButton_clean")
        self.gridLayout.addWidget(self.pushButton_clean, 3, 0, 1, 1)
        self.pushButton_selectimg = QtWidgets.QPushButton(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton_selectimg.setFont(font)
        self.pushButton_selectimg.setObjectName("pushButton_selectimg")
        self.gridLayout.addWidget(self.pushButton_selectimg, 3, 1, 1, 1)
        self.label_objclass = QtWidgets.QLabel(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_objclass.setFont(font)
        self.label_objclass.setObjectName("label_objclass")
        self.gridLayout.addWidget(self.label_objclass, 2, 0, 1, 1)
        self.pushButton_start = QtWidgets.QPushButton(self.groupBox_3)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton_start.setFont(font)
        self.pushButton_start.setObjectName("pushButton_start")
        self.gridLayout.addWidget(self.pushButton_start, 3, 2, 1, 1)
        self.verticalLayout_3.addLayout(self.gridLayout)
        self.horizontalLayout_2.addWidget(self.groupBox_3)
        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.tab_2)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.groupBox_4 = QtWidgets.QGroupBox(self.tab_2)
        self.groupBox_4.setMinimumSize(QtCore.QSize(405, 600))
        self.groupBox_4.setMaximumSize(QtCore.QSize(405, 6000))
        self.groupBox_4.setTitle("")
        self.groupBox_4.setObjectName("groupBox_4")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.groupBox_4)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.groupBox_6 = QtWidgets.QGroupBox(self.groupBox_4)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.groupBox_6.setFont(font)
        self.groupBox_6.setObjectName("groupBox_6")
        self.pushButton_11 = QtWidgets.QPushButton(self.groupBox_6)
        self.pushButton_11.setGeometry(QtCore.QRect(230, 120, 94, 32))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.pushButton_11.setFont(font)
        self.pushButton_11.setObjectName("pushButton_11")
        self.pushButton_10 = QtWidgets.QPushButton(self.groupBox_6)
        self.pushButton_10.setGeometry(QtCore.QRect(0, 120, 120, 32))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.pushButton_10.setFont(font)
        self.pushButton_10.setObjectName("pushButton_10")
        self.label_6 = QtWidgets.QLabel(self.groupBox_6)
        self.label_6.setGeometry(QtCore.QRect(0, 160, 371, 16))
        self.label_6.setObjectName("label_6")
        self.label_10 = QtWidgets.QLabel(self.groupBox_6)
        self.label_10.setGeometry(QtCore.QRect(0, 190, 371, 16))
        self.label_10.setObjectName("label_10")
        self.label_18 = QtWidgets.QLabel(self.groupBox_6)
        self.label_18.setGeometry(QtCore.QRect(0, 220, 371, 351))
        self.label_18.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_18.setWordWrap(True)
        self.label_18.setObjectName("label_18")
        self.layoutWidget = QtWidgets.QWidget(self.groupBox_6)
        self.layoutWidget.setGeometry(QtCore.QRect(0, 30, 227, 81))
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label_14 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.label_14.setFont(font)
        self.label_14.setObjectName("label_14")
        self.verticalLayout_7.addWidget(self.label_14)
        self.label_17 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.label_17.setFont(font)
        self.label_17.setObjectName("label_17")
        self.verticalLayout_7.addWidget(self.label_17)
        self.label_19 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(False)
        font.setWeight(50)
        self.label_19.setFont(font)
        self.label_19.setObjectName("label_19")
        self.verticalLayout_7.addWidget(self.label_19)
        self.layoutWidget1 = QtWidgets.QWidget(self.groupBox_6)
        self.layoutWidget1.setGeometry(QtCore.QRect(230, 30, 161, 81))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.guanjianci = QtWidgets.QPlainTextEdit(self.layoutWidget1)
        self.guanjianci.setObjectName("guanjianci")
        self.verticalLayout_6.addWidget(self.guanjianci)
        self.shuliang = QtWidgets.QPlainTextEdit(self.layoutWidget1)
        self.shuliang.setObjectName("shuliang")
        self.verticalLayout_6.addWidget(self.shuliang)
        self.liebei = QtWidgets.QPlainTextEdit(self.layoutWidget1)
        self.liebei.setObjectName("liebei")
        self.verticalLayout_6.addWidget(self.liebei)
        self.verticalLayout_5.addWidget(self.groupBox_6)
        self.horizontalLayout_3.addWidget(self.groupBox_4)
        self.groupBox_2 = QtWidgets.QGroupBox(self.tab_2)
        self.groupBox_2.setTitle("")
        self.groupBox_2.setObjectName("groupBox_2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.groupBox_2)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.groupBox_7 = QtWidgets.QGroupBox(self.groupBox_2)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.groupBox_7.setFont(font)
        self.groupBox_7.setObjectName("groupBox_7")
        self.groupBox_5 = QtWidgets.QGroupBox(self.groupBox_7)
        self.groupBox_5.setGeometry(QtCore.QRect(10, 30, 451, 321))
        self.groupBox_5.setObjectName("groupBox_5")
        self.label_23 = QtWidgets.QLabel(self.groupBox_5)
        self.label_23.setGeometry(QtCore.QRect(207, 33, 16, 16))
        self.label_23.setText("")
        self.label_23.setObjectName("label_23")
        self.label_27 = QtWidgets.QLabel(self.groupBox_5)
        self.label_27.setGeometry(QtCore.QRect(100, 60, 81, 20))
        self.label_27.setObjectName("label_27")
        self.q = QtWidgets.QPushButton(self.groupBox_5)
        self.q.setGeometry(QtCore.QRect(200, 60, 111, 21))
        self.q.setObjectName("q")
        self.label_28 = QtWidgets.QLabel(self.groupBox_5)
        self.label_28.setGeometry(QtCore.QRect(120, 190, 81, 21))
        self.label_28.setObjectName("label_28")
        self.plainTextEdit_6 = QtWidgets.QPlainTextEdit(self.groupBox_5)
        self.plainTextEdit_6.setEnabled(True)
        self.plainTextEdit_6.setGeometry(QtCore.QRect(210, 190, 81, 21))
        self.plainTextEdit_6.setObjectName("plainTextEdit_6")
        self.pushButton_9 = QtWidgets.QPushButton(self.groupBox_5)
        self.pushButton_9.setGeometry(QtCore.QRect(100, 240, 94, 32))
        self.pushButton_9.setObjectName("pushButton_9")
        self.pushButton_5 = QtWidgets.QPushButton(self.groupBox_5)
        self.pushButton_5.setGeometry(QtCore.QRect(280, 240, 94, 32))
        self.pushButton_5.setObjectName("pushButton_5")
        self.label_5 = QtWidgets.QLabel(self.groupBox_5)
        self.label_5.setEnabled(False)
        self.label_5.setGeometry(QtCore.QRect(140, 220, 195, 18))
        self.label_5.setObjectName("label_5")
        self.label_11 = QtWidgets.QLabel(self.groupBox_5)
        self.label_11.setGeometry(QtCore.QRect(100, 90, 441, 20))
        self.label_11.setObjectName("label_11")
        self.label_12 = QtWidgets.QLabel(self.groupBox_5)
        self.label_12.setGeometry(QtCore.QRect(100, 120, 101, 18))
        self.label_12.setObjectName("label_12")
        self.pushButton_2 = QtWidgets.QPushButton(self.groupBox_5)
        self.pushButton_2.setGeometry(QtCore.QRect(200, 120, 113, 21))
        self.pushButton_2.setObjectName("pushButton_2")
        self.label_13 = QtWidgets.QLabel(self.groupBox_5)
        self.label_13.setGeometry(QtCore.QRect(100, 139, 451, 31))
        self.label_13.setObjectName("label_13")
        self.label_20 = QtWidgets.QLabel(self.groupBox_5)
        self.label_20.setGeometry(QtCore.QRect(20, 20, 501, 31))
        self.label_20.setObjectName("label_20")
        self.label_21 = QtWidgets.QLabel(self.groupBox_5)
        self.label_21.setGeometry(QtCore.QRect(290, 190, 60, 21))
        self.label_21.setObjectName("label_21")
        self.label_22 = QtWidgets.QLabel(self.groupBox_5)
        self.label_22.setGeometry(QtCore.QRect(90, 170, 111, 20))
        self.label_22.setObjectName("label_22")
        self.plainTextEdit_7 = QtWidgets.QPlainTextEdit(self.groupBox_5)
        self.plainTextEdit_7.setEnabled(True)
        self.plainTextEdit_7.setGeometry(QtCore.QRect(210, 170, 191, 21))
        self.plainTextEdit_7.setObjectName("plainTextEdit_7")
        self.label_24 = QtWidgets.QLabel(self.groupBox_5)
        self.label_24.setGeometry(QtCore.QRect(400, 170, 60, 21))
        self.label_24.setObjectName("label_24")
        self.label = QtWidgets.QLabel(self.groupBox_5)
        self.label.setGeometry(QtCore.QRect(210, 240, 61, 31))
        self.label.setObjectName("label")
        self.label_3 = QtWidgets.QLabel(self.groupBox_5)
        self.label_3.setGeometry(QtCore.QRect(160, 270, 111, 31))
        self.label_3.setObjectName("label_3")
        self.pushButton_6 = QtWidgets.QPushButton(self.groupBox_5)
        self.pushButton_6.setGeometry(QtCore.QRect(280, 270, 94, 32))
        self.pushButton_6.setObjectName("pushButton_6")
        self.textEdit_8 = QtWidgets.QTextEdit(self.groupBox_7)
        self.textEdit_8.setEnabled(True)
        self.textEdit_8.setGeometry(QtCore.QRect(10, 360, 451, 221))
        self.textEdit_8.setObjectName("textEdit_8")
        self.verticalLayout_4.addWidget(self.groupBox_7)
        self.horizontalLayout_3.addWidget(self.groupBox_2)
        self.tabWidget.addTab(self.tab_2, "")
        self.Tab2 = QtWidgets.QWidget()
        self.Tab2.setObjectName("Tab2")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.Tab2)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.label_introduction = QtWidgets.QLabel(self.Tab2)
        self.label_introduction.setText("")
        self.label_introduction.setPixmap(QtGui.QPixmap("../pics/trash.6.jpg"))
        self.label_introduction.setObjectName("label_introduction")
        self.gridLayout_2.addWidget(self.label_introduction, 2, 0, 1, 2)
        self.label_ourinfo = QtWidgets.QLabel(self.Tab2)
        self.label_ourinfo.setObjectName("label_ourinfo")
        self.gridLayout_2.addWidget(self.label_ourinfo, 3, 1, 1, 1)
        self.label_15 = QtWidgets.QLabel(self.Tab2)
        self.label_15.setObjectName("label_15")
        self.gridLayout_2.addWidget(self.label_15, 1, 0, 1, 1)
        self.tabWidget.addTab(self.Tab2, "")
        self.horizontalLayout.addWidget(self.tabWidget)

        self.retranslateUi(classification)
        self.tabWidget.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(classification)

    def retranslateUi(self, classification):
        _translate = QtCore.QCoreApplication.translate
        classification.setWindowTitle(_translate("classification", "Classification"))
        self.label_16.setText(_translate("classification", "选择模型"))
        self.pushButton.setText(_translate("classification", "从文件夹添加模型 "))
        self.comboBox.setItemText(0, _translate("classification", "从文件夹读取"))
        self.label_7.setText(_translate("classification", "当前选择模型："))
        self.label_modelname.setText(_translate("classification", "模型名字"))
        self.label_2.setText(_translate("classification", "具体名称"))
        self.label_4.setText(_translate("classification", "垃圾种类"))
        self.label_costtime.setText(_translate("classification", "总用时：0s"))
        self.label_accuracy.setText(_translate("classification", "等待开始识别~"))
        self.label_objname.setText(_translate("classification", "Waiting for loading"))
        self.pushButton_clean.setText(_translate("classification", "清空所有"))
        self.pushButton_selectimg.setText(_translate("classification", "选择图片"))
        self.label_objclass.setText(_translate("classification", "Waiting for loading"))
        self.pushButton_start.setText(_translate("classification", "识别"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("classification", "开始垃圾分类"))
        self.groupBox_6.setTitle(_translate("classification", "爬取图片"))
        self.pushButton_11.setText(_translate("classification", "开始爬取"))
        self.pushButton_10.setText(_translate("classification", "设置存放目录"))
        self.label_6.setText(_translate("classification", "显示选择的路径："))
        self.label_10.setText(_translate("classification", "显示正在打印第几张"))
        self.label_18.setText(_translate("classification", "目录具有的分类：暂未选择目录"))
        self.label_14.setText(_translate("classification", "输入关键词(例:苹果)"))
        self.label_17.setText(_translate("classification", "爬取数量(输入1即代表60张,例:1)"))
        self.label_19.setText(_translate("classification", "规定名称(例：其他垃圾_卫生纸)"))
        self.groupBox_7.setTitle(_translate("classification", "模型训练"))
        self.groupBox_5.setTitle(_translate("classification", "训练调参"))
        self.label_27.setText(_translate("classification", "数据集路径"))
        self.q.setText(_translate("classification", "点击选取路径"))
        self.label_28.setText(_translate("classification", "训练次数："))
        self.pushButton_9.setText(_translate("classification", "停止训练"))
        self.pushButton_5.setText(_translate("classification", "开始训练"))
        self.label_5.setText(_translate("classification", "提示：训练次数越多，用时越长～"))
        self.label_11.setText(_translate("classification", "显示选取的路径：暂无"))
        self.label_12.setText(_translate("classification", "模型保存路径"))
        self.pushButton_2.setText(_translate("classification", "点击选取路径"))
        self.label_13.setText(_translate("classification", "显示模型保存路径：暂无"))
        self.label_20.setText(_translate("classification", "提示：训练会自动进行训练集与验证集划分，所以只需要给定数据集即可"))
        self.label_21.setText(_translate("classification", "次"))
        self.label_22.setText(_translate("classification", " 保存模型名称："))
        self.label_24.setText(_translate("classification", ".h5"))
        self.label.setText(_translate("classification", "CNN网络："))
        self.label_3.setText(_translate("classification", "Mobilennet网络："))
        self.pushButton_6.setText(_translate("classification", "开始训练"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("classification", "爬虫与模型训练"))
        self.label_ourinfo.setText(_translate("classification", "一些相关信息"))
        self.label_15.setText(_translate("classification", "垃圾分类"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Tab2), _translate("classification", "更多"))


# 以上代码为GUI界面代码
# ----------------------------分割线----------------------------
# ----------------------------分割线----------------------------
# ----------------------------分割线----------------------------
# 以下代码为GUI界面功能、按键、文本框交互实现函数

# 多线程，用于在UI界面的框里实时打印终端信息
class EmittingStream(QtCore.QObject):
    textWritten=QtCore.pyqtSignal(str)
    # 将终端文字进行输出
    def write(self,text):
        self.textWritten.emit(str(text))
    # 显示流动图像，比如显示Tensorflow训练过程
    def flush(self):
        # 多线程，可以使程序实时现实训练过程
        QApplication.processEvents()
        # pass


# 动态载入GUI界面
class Mainwindow(QWidget,Ui_classification):
    def __init__(self):
        super().__init__()
        # 初始化
        self.setupUi(self)
        self.retranslateUi(self)
        self.target=" "
        # 设置标题与小logo
        file_path=os.getcwd()
        self.setWindowIcon(QIcon(file_path+'/图标.png'))
        # 设置程序标题
        self.setWindowTitle('垃圾分类识别系统')
        # 设置基础函数
        self.init()

    # 设置需要使用到的基础交互函数（绑定每个按钮的功能函数）
    def init(self):
        # 设置主页图片
        file_path=os.getcwd()
        self.target=file_path+"/初始化图片.jpg"
        # 用opencv更改图片的尺寸，适配界面的大小
        # img=cv2.imread(self.target)
        # self.target=cv2.resize(img,(self.label_9.width(),self.label_9.height()))
        # 绑定按钮功能
        # 链接"选择检测图片"函数
        self.pushButton_selectimg.clicked.connect(self.button_selecttarget)
        # 链接"开始识别"函数
        self.pushButton_start.clicked.connect(self.predict_img)
        # 链接"清空所有"函数
        self.pushButton_clean.clicked.connect(self.clean)
        # 链接"选择模型"函数
        self.pushButton.clicked.connect(self.get_models)
        # 检测拖选框选取激活，可以调用函数检测拖选框选取的内容
        self.comboBox.activated.connect(self.chang_models)
        # 链接"选择爬取图片存放文件夹"函数
        self.pushButton_10.clicked.connect(self.choose_getdata_path)
        # 链接爬虫"开始爬取"函数
        self.pushButton_11.clicked.connect(self.run_getdata)
        # 链接"数据集位置"函数
        self.q.clicked.connect(self.get_train_path)
        # 链接"模型保存"函数
        self.pushButton_2.clicked.connect(self.model_save)
        # 链接"CNN训练"函数
        self.pushButton_5.clicked.connect(self.train_CNN)
        # 链接"Mobilenet"函数
        self.pushButton_6.clicked.connect(self.train_mobilenet)
        # # 控制台内容输出
        sys.stdout=EmittingStream(textWritten=self.outputWritten)
        sys.stderr=EmittingStream(textWritten=self.outputWritten)

    # 获取模型函数（用于在拖选框展示文件夹里面有哪些模型可以选择）
    def get_models(self):
        # 返回储存选择模型所在文件夹
        # 这里修复第5个bug，不然就会在选取时点取消而报错
        try:
            self.get_model=QFileDialog.getExistingDirectory(self,"请选择文件夹路径")
        except Exception as e:
            self.get_models()
        # 创建列表，将所有模型储存在里面
        self.models=os.listdir(self.get_model)
        # 删除'.DS_Store'，这个会在macos中报错
        if '.DS_Store' in self.models:
            self.models.remove('.DS_Store')
        # 这里设置一个循环，只显示.h5模型文件，不显示其他的文件
        # 修复第10个bug，该bug会导致索引数组数据出问题
        models=[]
        for i in range(len(self.models)):
            if '.h5' in self.models[i]:
                models.append(self.models[i])
        self.models=models
        # 创建拖选框的内容（展示模型）
        # 先清空之前拖选框的内容
        self.comboBox.clear()
        # 用循环添加新的内容进行展示
        for i in range(len(self.models)):
            self.comboBox.addItem(self.models[i])

    # 切换模型函数（就是那个拖选框的）
    def chang_models(self):
        # 获取拖选框选择的内容（模型）
        self.x=self.comboBox.currentText()
        # 这个函数可以使UI界面实时显示选择的模型
        self.label_modelname.setText(self.x)
        # 这里修复第三个bug，如果不修复则可能导致，在拖选框中选中文字提示："从文件夹读取"内容，会报错没有选择模型文件夹
        try:
            print(self.get_model)
        except:
            self.chang_models
        # 定义模型路径
        # 这里修复第二个bug，如果不修复则可能导致，在拖选框中选中文字提示："从文件夹读取"内容，而导致误以为是模型名
        try:
            self.model=tf.keras.models.load_model(self.get_model+'/'+self.x)
        except Exception as e:
            self.chang_models
        # 定义类别名（如果是系统自带的话，就是以下的类别名,）
        if self.x=='软件自带CNN_1.h5' or self.x=='软件自带CNN_2.h5' or self.x=='软件自带mobilenet.h5':
            self.class_names=['其他垃圾_PE塑料袋','其他垃圾_U型回形针','其他垃圾_一次性杯子','其他垃圾_一次性棉签','其他垃圾_串串竹签','其他垃圾_便利贴','其他垃圾_创可贴',
                            '其他垃圾_卫生纸','其他垃圾_厨房手套','其他垃圾_厨房抹布','其他垃圾_口罩','其他垃圾_唱片','其他垃圾_图钉','其他垃圾_大龙虾头',
                            '其他垃圾_奶茶杯','其他垃圾_干燥剂','其他垃圾_彩票','其他垃圾_打泡网','其他垃圾_打火机','其他垃圾_搓澡巾','其他垃圾_果壳','其他垃圾_毛巾',
                            '其他垃圾_涂改带','其他垃圾_湿纸巾','其他垃圾_烟蒂','其他垃圾_牙刷','其他垃圾_电影票','其他垃圾_电蚊香','其他垃圾_百洁布','其他垃圾_眼镜',
                            '其他垃圾_眼镜布','其他垃圾_空调滤芯','其他垃圾_笔','其他垃圾_胶带','其他垃圾_胶水废包装','其他垃圾_苍蝇拍','其他垃圾_茶壶碎片',
                            '其他垃圾_草帽','其他垃圾_菜板','其他垃圾_车票','其他垃圾_酒精棉','其他垃圾_防霉防蛀片','其他垃圾_除湿袋','其他垃圾_餐巾纸',
                            '其他垃圾_餐盒','其他垃圾_塑料袋','其他垃圾_鸡毛掸','厨余垃圾_八宝粥','厨余垃圾_冰激凌','厨余垃圾_冰糖葫芦','厨余垃圾_咖啡',
                            '厨余垃圾_圣女果','厨余垃圾_地瓜','厨余垃圾_坚果','厨余垃圾_壳','厨余垃圾_巧克力','厨余垃圾_果冻','厨余垃圾_果皮','厨余垃圾_核桃',
                            '厨余垃圾_梨','厨余垃圾_橙子','厨余垃圾_残渣剩饭','厨余垃圾_水果','厨余垃圾_泡菜','厨余垃圾_火腿','厨余垃圾_火龙果','厨余垃圾_烤鸡',
                            '厨余垃圾_瓜子','厨余垃圾_甘蔗','厨余垃圾_番茄','厨余垃圾_秸秆杯','厨余垃圾_秸秆碗','厨余垃圾_粉条','厨余垃圾_肉类','厨余垃圾_肠',
                            '厨余垃圾_苹果','厨余垃圾_茶叶','厨余垃圾_草莓','厨余垃圾_菠萝','厨余垃圾_菠萝蜜','厨余垃圾_萝卜','厨余垃圾_蒜','厨余垃圾_蔬菜',
                            '厨余垃圾_薯条','厨余垃圾_薯片','厨余垃圾_蘑菇','厨余垃圾_蛋','厨余垃圾_蛋挞','厨余垃圾_蛋糕','厨余垃圾_豆','厨余垃圾_豆腐',
                            '厨余垃圾_辣椒','厨余垃圾_面包','厨余垃圾_饼干','厨余垃圾_鸡翅','可回收物_不锈钢制品','可回收物_乒乓球拍','可回收物_书','可回收物_体重秤',
                            '可回收物_保温杯','可回收物_保鲜膜内芯','可回收物_信封','可回收物_充电头','可回收物_充电宝','可回收物_充电牙刷','可回收物_充电线',
                            '可回收物_凳子','可回收物_刀','可回收物_包','可回收物_单车','可回收物_卡','可回收物_台灯','可回收物_吊牌','可回收物_吹风机',
                            '可回收物_呼啦圈','可回收物_地球仪','可回收物_地铁票','可回收物_垫子','可回收物_塑料制品','可回收物_太阳能热水器','可回收物_奶粉桶',
                            '可回收物_尺子','可回收物_尼龙绳','可回收物_布制品','可回收物_帽子','可回收物_手机','可回收物_手电筒','可回收物_手表','可回收物_手链',
                            '可回收物_打包绳','可回收物_打印机','可回收物_打气筒','可回收物_扫地机器人','可回收物_护肤品空瓶','可回收物_拉杆箱','可回收物_拖鞋',
                            '可回收物_插线板','可回收物_搓衣板','可回收物_收音机','可回收物_放大镜','可回收物_日历','可回收物_暖宝宝','可回收物_望远镜',
                            '可回收物_木制切菜板','可回收物_木桶','可回收物_木棍','可回收物_木质梳子','可回收物_木质锅铲','可回收物_木雕','可回收物_枕头',
                            '可回收物_果冻杯','可回收物_桌子','可回收物_棋子','可回收物_模具','可回收物_毯子','可回收物_水壶','可回收物_水杯','可回收物_沙发',
                            '可回收物_泡沫板','可回收物_灭火器','可回收物_灯罩','可回收物_烟灰缸','可回收物_热水瓶','可回收物_燃气灶','可回收物_燃气瓶',
                            '可回收物_玩具','可回收物_玻璃制品','可回收物_玻璃器皿','可回收物_玻璃壶','可回收物_玻璃球','可回收物_瑜伽球','可回收物_电动剃须刀',
                            '可回收物_电动卷发棒','可回收物_电子秤','可回收物_电熨斗','可回收物_电磁炉','可回收物_电脑屏幕','可回收物_电视机','可回收物_电话',
                            '可回收物_电路板','可回收物_电风扇','可回收物_电饭煲','可回收物_登机牌','可回收物_盒子','可回收物_盖子','可回收物_盘子','可回收物_碗',
                            '可回收物_磁铁','可回收物_空气净化器','可回收物_空气加湿器','可回收物_笼子','可回收物_箱子','可回收物_纸制品','可回收物_纸牌',
                            '可回收物_罐子','可回收物_网卡','可回收物_耳套','可回收物_耳机','可回收物_衣架','可回收物_袋子','可回收物_袜子','可回收物_裙子',
                            '可回收物_裤子','可回收物_计算器','可回收物_订书机','可回收物_话筒','可回收物_豆浆机','可回收物_路由器','可回收物_轮胎','可回收物_过滤网',
                            '可回收物_遥控器','可回收物_量杯','可回收物_金属制品','可回收物_钉子','可回收物_钥匙','可回收物_铁丝球','可回收物_铅球',
                            '可回收物_铝制用品','可回收物_锅','可回收物_锅盖','可回收物_键盘','可回收物_镊子','可回收物_闹铃','可回收物_雨伞','可回收物_鞋',
                            '可回收物_音响','可回收物_餐具','可回收物_餐垫','可回收物_饰品','可回收物_鱼缸','可回收物_鼠标','有害垃圾_指甲油','有害垃圾_杀虫剂',
                            '有害垃圾_温度计','有害垃圾_灯','有害垃圾_电池','有害垃圾_电池板','有害垃圾_纽扣电池','有害垃圾_胶水','有害垃圾_药品包装','有害垃圾_药片',
                            '有害垃圾_药瓶','有害垃圾_药膏','有害垃圾_蓄电池','有害垃圾_血压计']
        # 读取自己训练的模型的类别名
        else:
            # 首先先去掉.h5后缀，因为是打开.txt
            self.y=self.x.strip('.h5')
            # 打开模型对应的txt
            f=open(self.get_model+'/'+self.y+'.txt','r')
            # 创建空列表存放模型名
            ls=[]
            # 循环读取并去掉'\n'
            for line in f.readlines():
                line=line.strip('\n')
                ls.append(line)
            # 赋值即可，这里的class_names便是我们自己训练的模型的模型名
            self.class_names=ls

    # 选择需要识别的图片
    def button_selecttarget(self):
        print('选择图片：')
        # 第一个bug修许，这里修复一个常见bug，如果不用try和expect，会在点击"选择图片"后，点"取消选择"时报错
        try:
            # 获得需要预测图片的路径
            self.imgPath,imgType=QFileDialog.getOpenFileName(self,"打开图片","","*.png;;*.jpg;;*jpeg;;All Files(*)")
            img=QPixmap(self.imgPath).scaled(self.label_9.width(),self.label_9.height())
            # 显示选择的图片
            self.label_9.setPixmap(img)
        except Exception as e:
            # 取消了就重来
            self.button_selecttarget()
            self.label_9.setPixmap(QPixmap(self.target))
        # 这里直接加载，或许可以使用opencv-的resize函数将图片缩放后存放在指定的文件夹以供后续系统地查看
        # print(self.imgPath)

    # 点击按钮，开始识别图片
    def predict_img(self):
        # 修复第11个bug，该bug导致opencv不能读取中文路径图片
        img_data=np.fromfile(self.imgPath,np.uint8)
        img=cv2.imdecode(img_data,-1)
        # # 将图片大小调整到224*224用于图片编码，以及分类预测
        img=cv2.resize(img, (224, 224))
        # 读取图片
        # cv2.imshow('img',img)
        # 将图片转化为numpy的数组
        img=np.asarray(img)
        # 开始计时
        start_time=time.time()
        # 将图片输入得到分类结果
        # 这里的model是我们之前选择的.h5模型
        outputs = self.model(img.reshape(1, 224, 224, 3))
        result_index = int(np.argmax(outputs))
        print(self.class_names)
        # 获得对应的名称
        result = self.class_names[result_index]
        # 记录结束时间
        endtime = time.time()
        timeusing = round(endtime-start_time, 2)
        # 最终打印结果
        print(result)
        # 将结果用_隔开
        names = result.split("_")
        # 分成种类和垃圾名字
        objClass=names[0]
        objName=names[1]
        # 显示在UI界面
        self.label_objname.setText(objName)
        self.label_objclass.setText(objClass)
        self.label_costtime.setText(f'总用时{str(timeusing)} 秒')
        self.label_accuracy.setText("已完成识别～")

    # 清空所有东西
    def clean(self):
        print("清空")
        # 将图片与文本框设置为初始化
        self.label_9.setText("")
        self.label_9.setPixmap(QPixmap(self.target))
        self.label_costtime.setText("总用时：0s")
        self.label_accuracy.setText("请开始识别～")
        self.label_objname.setText("Waiting for loading")
        self.label_objclass.setText("Waiting for loading")
        # self.label_modelname.setText("模型名字")

    # 窗口关闭事件
    def closeEvent(self,event):
        reply=QMessageBox.question(self,
                                     '退出',
                                     "是否要退出程序？",
                                     QMessageBox.Yes | QMessageBox.No,
                                     QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.close()
            event.accept()
        else:
            event.ignore()

    # 选择保存爬取图片的文件夹
    def choose_getdata_path(self):
        # 选择存放图片的文件夹
        # 这里修复第4个bug，不然就会在选取时点取消而报错
        try:
            self.name_getdata_path=QFileDialog.getExistingDirectory(self,"请选择文件夹路径")
        except Exception as e:
            self.choose_getdata_path()
        # 显示选择的路径
        self.label_6.setText('当前选择路径：'+self.name_getdata_path)
        # 提示
        self.label_10.setText('提示：下载过程程序可能未响应，请稍等......')
        # 显示已有的分类情况
        # 这里修复第5个bug，不然就会在选取时点取消而报错
        try:
            total_files=os.listdir(self.name_getdata_path)
            self.label_18.setText('选择的目录已有分类为：'+str(total_files))
        except Exception as e:
            self.label_18.setText('选择的目录已有分类为：暂无')

    # 爬虫部分函数
    def run_getdata(self):
        # 伪装header，防止识别为爬虫
        headers={
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '
                          'AppleWebKit/537.36 (KHTML,like Gecko) '
                          'Chrome/84.0.4147.125 '
                          'Safari/537.36'}
        # 通过ui文本框输入获取爬取信息
        name=self.guanjianci.toPlainText()
        # 初始化后续使用变量
        num=0
        num_again=0 #用于保存当前路径(后续使用)
        num_problem=0 #也用于保存文件路径
        # 得到输入图片数量变量(60根据搜索的url所定)
        # 通过ui文本框获取爬取数量
        x=self.shuliang.toPlainText()
        list_1=[]
        filename_total=[]
        # 通过ui文本框获取爬取分类
        file_name=self.liebei.toPlainText()
        # 计时
        time_start=time.time()
        for i in range(int(x)):
            # os.getcwd()获得当前的路径
            # name_1=os.getcwd()
            # os.path.join连接两个或更多的路径名组件(这里用于保存图片储存路径，保存在当前路径中的/data文件夹)
            name_2=os.path.join(self.name_getdata_path+'/'+file_name)
            # 创建爬取网站，这里我默认使用Baidu
            url='https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word='
            url=url+name+'&pn='+str(i*30)

            # # 调用request函数，构造一个向服务器请求资源的url对象，返回从服务器获取的所有的相关资源
            # res=requests.get(url,headers=headers)
            # htlm_1=res.content.decode()

            # 这里使用我打算不实用上述的经典get，打算使用Session进行创建对象，之前在网上看到过使用Session可以服务器保持连接，使爬取速度加快
            res=requests.Session()
            htlm_1=res.get(url,headers=headers).content.decode()
            # 正则筛选
            # 匹配查找URL
            a=re.findall('"objURL":"(.*?)",',htlm_1)
            # 检测是否存在路径(这里用于保存图片储存路径，name_2表示保存在当前路径中的/data文件夹)
            if not os.path.exists(name_2):
                # 创建多层目录
                os.makedirs(name_2)
            for b in a:
                try:
                    # 添加获取图片的对应网址(为了保证爬取的图片不重复(至少不是相同的网址))
                    b_1=re.findall('https:(.*?)&',b)
                    b_2=''.join(b_1)
                    # 如果没有爬取过这个图片，就进行储存
                    if b_2 not in list_1:
                        num=num+1 #用于图片计数
                        # 创建Session
                        imgget=requests.Session()
                        img=imgget.get(b) #获取爬取图片
                        # 新建图片文件进行保存，图片名为XX第几张
                        filename=os.path.join(self.name_getdata_path+'/'+file_name,name+str(num)+'.png')
                        f=open(filename,'ab')
                        # 打印正在保存第几张
                        # 显示爬取过程
                        f.write(img.content)
                        # 添加多线程，下载时不会出现卡顿
                        QApplication.processEvents()
                        print(f'正在下载第{str(num)}张图片')
                        f.close()
                        # 将这个图片的信息保存在列表里，保证不重复下载图片
                        list_1.append(b_2)
                        # 保存每个图片的文件名
                        filename_total.append(filename)
                    elif b_2 in list_1:
                        num_again=num_again+1
                        continue
                except Exception :
                    print(f'第{str(num)}张图片下载出现问题')
                    num_problem=num_problem+1
                    continue

        # 停止计时
        time_end=time.time()
        self.label_10.setText(f'下载已完成！总计爬取用时{round(time_end-time_start,2)}秒')
        print(f'爬取图片完成，总共爬取{num+num_again+num_problem}张,'
              f'已保存{num}张,重复爬取{num_again}张,'
              f'爬取出现问题{num_problem}张')
        print(f'总计爬取用时{time_end-time_start}秒')
        # 检测空文件
        # 创建统计空文件数量变量
        num_blank=0
        # 遍历所有刚才下载的文件呢
        for i in filename_total:
            # print(i)
            # 如果文件大小小于200B，则当作空图片(个人感觉图片应该不止200B)
            if os.path.getsize(i)<200:
                print(f'{i}为空图片')
                # 删除该文件
                os.unlink(i)
                filename_total.remove(i)
                num_blank+=1
                continue
        if num_blank==0:
            print('此次下载没有空图片')
        else:
            print(f'经检测，下载到共有{num_blank}张空图片，已删除')

        # 检测错误图片（比如图片类型错误，虽然后缀为'png'，但还是可能打不开图片）
        for file in filename_total:
            # 判断是不是有效的jepg
            def is_valid_jpg(jpg_file):
                with open(jpg_file,'rb') as f:
                    f.seek(-2,2)
                    buf=f.read()
                    return buf==b'\xff\xd9'

            # 判断是不是有效的png
            def is_valid_png(png_file):
                with open(png_file,'rb') as f:
                    f.seek(-3,2)
                    buf=f.read()
                    if buf==b'\x60\x82\x00':
                        return True
                    elif buf[1:]==b'\x60\x82':
                        return True
                    else:
                        return False

            # 判断是不是有效的图片类型（jepg和png）
            def is_valid_pic(pic_file):
                if pic_file.endswith('jpeg'):
                    return is_valid_jpg(pic_file)
                elif pic_file.endswith('png'):
                    return is_valid_png(pic_file)
                else:
                    return False

            # 遍历所有有图片的文件
            if not is_valid_pic(file):
                try:
                    img=Image.open(file)
                    img.load()
                except Exception as e:
                    print(f'{file}  不是合格的图片，这里将其删除！')
                    # shutil.copy(pic_file)
                    os.remove(file)
        total_files=os.listdir(self.name_getdata_path)
        self.label_18.setText('选择的目录已有分类为：'+str(total_files))

    # 选择训练集的文件夹
    def get_train_path(self):
        # 获取数据集目录
        try:
            self.get_train=QFileDialog.getExistingDirectory(self,"请选择文件夹路径")
        except Exception as e:
            self.get_train_path()
        self.datasets_init(origin_data=self.get_train,
                           datasets='datasets',
                           train_datasets_rate=0.9,validate_datasets_rate=0.05,test_datasets_rate=0.05)
        # 显示目前选取的路径
        self.label_11.setText('显示选取的路径：'+self.get_train)

    def datasets_init(self,origin_data,datasets,train_datasets_rate=0.8,validate_datasets_rate=0.2,
                      test_datasets_rate=0.0):
        # 这里可以自定义划分每种数据集的比例，默认训练集占比0.8，验证集占比0.2，预测集不划分
        # 这里修复第9个bug，如果使用os.remove会没有权限
        # 这里修复第12个bug，这里必须使用getcwd（）获取当前路径
        file_path=os.getcwd()
        file_names=os.listdir(file_path)
        if 'datasets' in file_names:
        # os.remove('datasets')
            shutil.rmtree('datasets') # todo 这里需保留，测试时先使用手动删除
        print(f'开始创建训练集比例为{train_datasets_rate * 100}%,'
              f'验证集比例为{validate_datasets_rate * 100}%,'
              f'预测集比例为{test_datasets_rate * 100}%')
        # 创建多层目录
        origin_datasets=os.listdir(origin_data)
        # 在目标目录下创建文件夹
        datasets_types=['训练集','验证集','预测集']
        for datasets_type in datasets_types:
            # 连接两个或更多的路径名组件
            datasets_path=os.path.join(datasets,datasets_type)
            # os.path.isdir()用于判断某一对象(需提供绝对路径)是否为目录
            if os.path.isdir(datasets_path):
                pass
            else:
                # 创建目录
                os.makedirs(datasets_path)
            # 然后在datasets_path的目录下创建类别文件夹
            # 遍历所有原始数据集
            for origin_data in origin_datasets:
                origin_datasets_path=os.path.join(datasets_path,origin_data)
                if os.path.isdir(origin_datasets_path):
                    pass
                else:
                    os.mkdir(origin_datasets_path)

            # 此处为MACOS会有系统文件夹'.DS_Store'，所以需要删除
            if '.DS_Store' in origin_datasets:
                origin_datasets.remove('.DS_Store')

        # 按照给定的或者默认的比例划分数据集，并进行数据图片的复制
        # 首先进行分类遍历
        print(f'一共需要划分{origin_datasets}类图片')
        for origin_data in origin_datasets:
            # 数据目录
            origin_datasets_path=os.path.join(self.get_train,origin_data)
            # 返回指定路径下的文件和文件夹列表
            current_all_data=os.listdir(origin_datasets_path)
            # 获得长度
            datasets_num=len(current_all_data)
            # 随机区分(用shuffle函数进行随机)
            current_data_index_list=list(range(datasets_num))
            random.shuffle(current_data_index_list)
            # 创建训练集目录
            train_folder=os.path.join(os.path.join(datasets,'训练集'),origin_data)
            # 创建验证集目录
            validate_folder=os.path.join(os.path.join(datasets,'验证集'),origin_data)
            # 创建预测集目录
            test_folder=os.path.join(os.path.join(datasets,'预测集'),origin_data)
            # 设定停止划分参数
            # 此处为统计总的原数据集样本数量，再乘以每一类比例
            flag_train=datasets_num * train_datasets_rate
            flag_validate=datasets_num * (train_datasets_rate+validate_datasets_rate)
            origin_num=0
            train_num=0
            validate_num=0
            test_num=0
            # 判断是否停止
            for i in current_data_index_list:
                src_img_path=os.path.join(origin_datasets_path,current_all_data[i])
                if origin_num<=flag_train:
                    # 复制图片
                    copy2(src_img_path,train_folder)
                    train_num+=1
                elif (origin_num>flag_train) and (origin_num<=flag_validate):
                    # 复制图片
                    copy2(src_img_path,validate_folder)
                    validate_num+=1
                else:
                    copy2(src_img_path,test_folder)
                    test_num+=1
                # 总的遍历文件数量参数
                origin_num+=1
            print(f'{origin_data}类图片划分完成！')
            print(f'数据集保存在工程文件中的《{datasets}》中，一共处理了{datasets_num}张图片')

    # 设定模型保存目录
    def model_save(self):
        # 获取模型保存目录
        try:
            self.get_model_save=QFileDialog.getExistingDirectory(self,"请选择文件夹路径")
        except Exception as e:
            self.model_save()
        self.label_13.setText('显示选取的路径：'+self.get_model_save)

    # 数据集加载函数，指明数据集的位置并统一处理为imgheight*imgwidth的大小，同时设置batch
    def load_dataset(self,train_datasets_path,validate_datasets_path,img_height,img_width,batch_size):
        # 此处需要传入训练集、验证集地址，图片高、宽、batch
        # 加载训练集(此处调用tf的keras库，从目录中的图像文件生成tf.data.Dataset)
        train_dataset=tf.keras.preprocessing.image_dataset_from_directory(
            train_datasets_path,# 数据集所在的目录位置
            label_mode='categorical',# ‘categorical’指标签被编码为分类向量
            seed=0,# 用于shuffle和转换的可选随机种子
            image_size=(img_height,img_width),# 图像处理大小
            batch_size=batch_size)  # 数据批次大小
        # 加载测试集(此处调用tf的keras库，从目录中的图像文件生成tf.data.Dataset)
        validate_dataset=tf.keras.preprocessing.image_dataset_from_directory(
            validate_datasets_path,# 数据集所在的目录位置
            label_mode='categorical',# ‘categorical’指标签被编码为分类向量
            seed=0,# 用于shuffle和转换的可选随机种子
            image_size=(img_height,img_width),# 图像处理大小
            batch_size=batch_size)  # 数据批次大小
        # 获得训练集的类名
        class_names=train_dataset.class_names
        # 返回处理之后的训练集、验证集和类名
        return train_dataset,validate_dataset,class_names

    # CNN模型训练函数，训练好的模型保存在工程文件下的'models'目录下
    # 构建CNN模型
    def CNN_modeltraining(self,class_num,IMG_SHAPE=(224,224,3)):
        # 搭建模型
        model=tf.keras.models.Sequential([
            # 对模型做归一化的处理，将0-255之间的数字统一处理到0到1之间
            # 归一化处理可以减少计算量，并且提高训练出的模型精度
            tf.keras.layers.experimental.preprocessing.Rescaling(1. / 255,input_shape=IMG_SHAPE),
            # 卷积层，该卷积层的输出为32个通道
            # 此处使用的卷积核的大小是3*3，激活函数使用relu
            tf.keras.layers.Conv2D(32,kernel_size=(3,3),activation='relu'),
            # 池化层，此处使用的kernel大小是2*2
            tf.keras.layers.MaxPooling2D(pool_size=(2,2)),
            # 增添另一个卷积池化
            # 卷积层，该卷积层的输出为64个通道
            # 此处使用的卷积核的大小是3*3，激活函数使用relu
            tf.keras.layers.Conv2D(64,kernel_size=(3,3),activation='relu'),
            # 池化层，此处使用的kernel大小是2*2
            tf.keras.layers.MaxPooling2D(pool_size=(2,2)),
            # 拉直层，将二维的输出转化为一维
            tf.keras.layers.Flatten(),
            # 全连接层，输出值维度为128，激活函数用的'relu'
            tf.keras.layers.Dense(128,activation='relu'),
            # 利用softmax函数的概率值进行分类
            tf.keras.layers.Dense(class_num,activation='softmax')])
        # 输出模型信息
        model.summary()
        # 配置模型训练方法，sgd优化器，损失函数为交叉熵函数，模型评价指标为正确率
        model.compile(optimizer='sgd',loss='categorical_crossentropy',metrics=['accuracy'])
        # 返回模型
        return model

    # 训练CNN函数
    def train_CNN(self):
        train_datesets='datasets/训练集'
        # 修复第6个bug，防止macos系统报错
        files=os.listdir(train_datesets)
        if '.DS_Store' in files:
            os.unlink(train_datesets+'/.DS_Store') # todo 这里训练时需要手动还是删除
        validate_datasets='datasets/验证集'
        # 从Ui文本框读取循环次数
        epochs=self.plainTextEdit_6.toPlainText()
        epochs=int(epochs)
        # 开始训练，记录开始时间
        time_start=time.time()
        # 导入训练集和验证集(此处调用了加载数据函数)
        # 此处需要传入训练集、验证集地址，图片高、宽、batch
        train_dataset,validate_dataset,class_names=self.load_dataset(train_datesets,validate_datasets,224,224,16)
        print(class_names)
        # 创建CNN模型
        model=self.CNN_modeltraining(class_num=len(class_names))
        # 训练
        model.fit(train_dataset,validation_data=validate_dataset,epochs=epochs)
        # 保存训练好的模型以备后续使用
        # 从Ui文本框读取
        name=self.plainTextEdit_7.toPlainText()
        model.save(self.get_model_save+'/'+name+'.h5')

        # 保存模型对应的类别名，以便于下次读取有类别名
        f_classnames=open(self.get_model_save+'/'+name+'.txt','w')
        for i in range(len(class_names)):
            f_classnames.write(class_names[i]+'\n')
        f_classnames.close()

        # 记录结束时间
        end_time=time.time()
        print(f'训练的总时间用时为：{end_time-time_start}秒')
        return class_names

    # 构建mobilenet模型
    # 模型加载，指定图片处理的大小和是否进行迁移学习
    def model_load(self,IMG_SHAPE=(224,224,3),class_num=0):
        # 微调的过程中这里不需要进行归一化的处理
        # 加载预训练的mobilenet模型
        base_model=tf.keras.applications.MobileNetV2(input_shape=IMG_SHAPE,include_top=False,weights='imagenet')
        # 将模型的主干参数进行冻结
        base_model.trainable=False
        model=tf.keras.models.Sequential([
            # 进行归一化的处理
            tf.keras.layers.experimental.preprocessing.Rescaling(1./127.5,offset=-1,input_shape=IMG_SHAPE),
            # 设置主干模型
            base_model,
            # 对主干模型的输出进行全局平均池化
            tf.keras.layers.GlobalAveragePooling2D(),
            # 通过全连接层映射到最后的分类数目上
            tf.keras.layers.Dense(class_num,activation='softmax')
        ])
        # 输出建立的模型信息
        model.summary()
        # 模型训练的优化器为adam优化器，模型的损失函数为交叉熵损失函数
        model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])
        return model

    # 训练mobilenet网络函数
    def train_mobilenet(self):
        train_datesets='datasets/训练集'
        validate_datasets='datasets/验证集'
        # 从Ui文本框读取循环次数
        epochs=self.plainTextEdit_6.toPlainText()
        epochs=int(epochs)
        # 开始训练，记录开始时间
        time_start=time.time()
        # 导入训练集和验证集(此处调用了加载数据函数)
        # 此处需要传入训练集、验证集地址，图片高、宽、batch
        train_dataset,validate_dataset,class_names=self.load_dataset(train_datesets,validate_datasets,224,224,16)
        # 打印训练集的所有类别
        print(class_names)
        # 训练mobilenet模型
        model=self.model_load(class_num=len(class_names))
        # 训练
        history=model.fit(train_dataset,validation_data=validate_dataset,epochs=epochs)
        # 保存训练好的模型以备后续使用
        # 从Ui文本框读取
        name=self.plainTextEdit_7.toPlainText()
        model.save(self.get_model_save+'/'+name+'.h5')
        # 保存模型对应的类别名，以便于下次读取有类别名
        f_classnames=open(self.get_model_save+'/'+name+'.txt','w')
        for i in range(len(class_names)):
            f_classnames.write(class_names[i]+'\n')
        f_classnames.close()
        # 记录结束时间
        end_time=time.time()
        print(f'训练的总时间用时为：{end_time-time_start}秒')
        return class_names

    # 将终端文字显示在Ui界面函数
    def outputWritten(self,text):
        cursor=self.textEdit_8.textCursor()
        cursor.movePosition(QTextCursor.End)
        cursor.insertText(text)
        self.textEdit_8.setTextCursor(cursor)
        self.textEdit_8.ensureCursorVisible()


if __name__=="__main__":
    # 首先用添加函数确保窗口可以随电脑分辨率而自适应
    QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling)
    app=QApplication(sys.argv)
    mainWindow=Mainwindow()
    # 这里与静态载入不同，使用 self.ui.show()
    # 如果使用 self.show(),会产生一个空白的 MainWindow 
    mainWindow.show()
    sys.exit(app.exec_())

# todo 文件位置不对的可能会报错
# todo 将划分数据集变为覆盖